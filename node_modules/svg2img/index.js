var canvg = require('canvg'),
    jsdom = require('jsdom'),
    atob = require('atob'),
    fs = require('fs'),
    http = require('http'),
    https = require('https'),
    Canvas = require('canvas');

var jsdomWindow = new jsdom.JSDOM().window;

/**
 * Main method
 * @param {String} svg - an SVG string, or a base64 string starting with "data:image/svg+xml;base64", or a file URL (http or local)
 * @param {Object} [options=null] - options
 * @param {Object} [options.format=png] - format of the image: png or jpeg, default is png
 * @param {Function} callback - result callback, with two parameters: error and the result buffer in PNG
 */
function svg2img(svg, options, callback) {
    function isFunction(func) {
        if (!func) {
            return false;
        }
        return typeof func === 'function' || (func.constructor !== null && func.constructor == Function);
    }

    if (isFunction(options)) {
        callback = options;
        options = {};
    }
    options = options || {};

    loadSVGContent(svg, async function (error, content) {
        if (error) {
            callback(error);
            return;
        }
        if (options.width || options.height) {
            content = scale(content, options.width, options.height, options.preserveAspectRatio);
        }
        var format = options.format || 'png';
        var canvas;
        try {
            canvas = await convert(content, options);
        } catch (error) {
            callback(error);
            return;
        }
        var stream;
        if (format === 'jpg' || format === 'jpeg') {
            stream = canvas.createJPEGStream({
                quality: options.quality || 75 // JPEG quality (0-100), default: 75
            });
        } else {
            stream = canvas.createPNGStream({
                compressionLevel: options.compressionLevel
            });
        }
        var data = [];
        stream.on('data', function (chunk) {
            data.push(chunk);
        });
        stream.on('error', function (error) {
            callback(error);
        });
        stream.on('end', function () {
            callback(null, Buffer.concat(data));
        });
    });
}

async function convert(svgContent, options) {
    var canvas = Canvas.createCanvas(options.width || 100, options.height || 100);
    var ctx = canvas.getContext('2d');
    try {
        const renderer = canvg.Canvg.fromString(ctx, svgContent, {
            DOMParser: jsdomWindow.DOMParser,
            window: jsdomWindow,
            ignoreMouse: true,
            ignoreAnimation: true,
            createCanvas: Canvas.createCanvas,
            createImage: Canvas.loadImage,
            ImageClass: Canvas.Image
        });
        await renderer.render();
        return canvas;
    } catch (error) {
        throw error;
    }
}

function scale(svgContent, w, h, preserveAspectRatio) {
    var index = svgContent.indexOf('<svg');
    var svgTag = [];
    var endIndex = index;
    for (var i = index; i < svgContent.length; i++) {
        var char = svgContent.charAt(i);
        svgTag.push(char);
        if (char === '>') {
            endIndex = i;
            break;
        }
    }
    svgTag = svgTag.join('').replace(/\n/g, ' ').replace(/\r/g, '');
    var finalAspectRatio;
    if (preserveAspectRatio) {
        if (typeof preserveAspectRatio === 'string') {
            finalAspectRatio = '"' + preserveAspectRatio + '"';
        } else {
            if (/ preserveAspectRatio\W/.test(svgContent)) {
                var quoChar = svgTag.match(/ preserveAspectRatio\s*=\s*(['"])/);
                if (quoChar) {
                    quoChar = quoChar[1];
                    var aspectRatio = svgTag.match(new RegExp(' preserveAspectRatio\\s*=\\s*' + quoChar + '([^' + quoChar + ']*)'));
                    if (aspectRatio && aspectRatio[1]) {
                        finalAspectRatio = aspectRatio[1].replace(/^\s*(\S.*\S)\s*$/, '"$1"');
                    }
                }
            }
        }
    }
    var props = {};
    var splits = svgTag.substring(4, svgTag.length - 1).split(' ');
    var lastKey;
    for (var i = 0; i < splits.length; i++) {
        if (splits[i] === '') {
            continue;
        } else {
            if (splits[i].indexOf('=') < 0) {
                props[lastKey] = props[lastKey] + ' ' + splits[i];
            } else {
                var keyvalue = splits[i].split('=');
                lastKey = keyvalue[0];
                props[lastKey] = keyvalue[1];
            }
        }
    }
    var ow = props['width'] ? parseInt(props['width'].replace('"', ''), 10) : null;
    var oh = props['height'] ? parseInt(props['height'].replace('"', ''), 10) : null;
    if (w) {
        props['width'] = '"' + w + '"';
    }
    if (h) {
        props['height'] = '"' + h + '"';
    }
    if (!props['viewBox']) {
        props['viewBox'] = '"' + [0, 0, ow ? ow : w, oh ? oh : h].join(' ') + '"';
    }
    props['preserveAspectRatio'] = finalAspectRatio || '"none"';

    // update width and height in the style attribute
    if (props['style'] && props['style'].length > 2) {
        var styleUpdated = false;
        var styleStr = props['style'].substring(1, props['style'].length - 1);
        var styles = styleStr.split(';');
        for (var i = 0; i < styles.length; i++) {
            var styleKV = styles[i].split(':');
            if (styleKV.length === 2) {
                var key = styleKV[0].trim();
                if (key === 'width') {
                    styles[i] = 'width : ' + w + 'px';
                    styleUpdated = true;
                } else if (key === 'height') {
                    styles[i] = 'height : ' + h + 'px';
                    styleUpdated = true;
                }
            }
        }
        if (styleUpdated) {
            props['style'] = '"' + styles.join(';') + '"';
        }
    }

    var newSvgTag = ['<svg'];
    for (var p in props) {
        newSvgTag.push(p + '=' + props[p]);
    }
    newSvgTag.push('>');
    return svgContent.substring(0, index) + newSvgTag.join(' ') + svgContent.substring(endIndex + 1);
}

function loadSVGContent(svg, callback) {
    if (Buffer.isBuffer(svg)) {
        svg = svg.toString('utf-8');
    }

    if (typeof svg !== 'string') {
        return callback(new Error('Invalid SVG data. Expected a string.'));
    }

    if (svg.indexOf('data:image/svg+xml;base64,') >= 0 && !/^<svg/.test(svg)) {
        callback(null, atob(svg.substring('data:image/svg+xml;base64,'.length)));
    } else if (svg.indexOf('<svg') >= 0) {
        callback(null, svg);
    } else {
        if (svg.indexOf('http://') >= 0 || svg.indexOf('https://') >= 0) {
            loadRemoteImage(svg, callback);
        } else {
            fs.readFile(svg, (error, data) => {
                if (error) {
                    callback(error);
                } else {
                    const fileContent = data.toString('utf-8');
                    if (fileContent.indexOf('<svg') >= 0) {
                        callback(null, fileContent);
                    } else {
                        callback(new Error('Invalid SVG data in the file.'));
                    }
                }
            });
        }
    }
}

module.exports = svg2img;
